import random
import numpy as np
from sympy.combinatorics import Permutation
from sympy.combinatorics.perm_groups import PermutationGroup
import math
import copy

def sample_partition(n):
    """
    Uniformly sample a partition of an integer n.
    The algorithm was adapted from the Stack Overflow post based on Fristedt, B. (1993):
    https://stackoverflow.com/questions/2161406/how-do-i-generate-a-uniform-random-integer-partition
    """
    
    x = np.exp(-np.pi/np.sqrt(6*n))
    probs = [1 - x**i for i in range(1, n+1)]
    
    stop = False
    while not stop:

        RVs = [np.random.geometric(probs[i]) - 1 for i in range(n)]

        total = 0
        for i in range(n):
            total += (i+1)*RVs[i]

        if total == n:
            stop = True

    partition = []
    for i in range(n):
        for j in range(RVs[i]):
            partition.append(i+1)
            
    partition.reverse()
    return partition


def partition_to_permutation(partition):
    """
    Given an integer partition, convert it to its canonical permutation.
    """
    
    total = 0
    permutation = []
    
    for cycle_size in partition:
        cycle = list(range(total, total + cycle_size))
        permutation.append(cycle)
        total += cycle_size
        
    return permutation


def sample_permutation(n):
    """
    Uniformly sample a permutation from the symmetric group S_n.
    """
    
    array_form = list(range(n))
    random.shuffle(array_form)
    permutation = Permutation(array_form).full_cyclic_form
    
    return permutation


class Triangulation:
    """
    Useful methods and attributes associated with the triangulation corresponding to a permutation pair (mu, sigma).
    """
    
    all_swaps = [
        ["red", "green", "blue"],
        ["red", "blue", "green"],
        ["blue", "red", "green"],
        ["blue", "green", "red"],
        ["green", "red", "blue"],
        ["green", "blue", "red"],
    ]
    
    
    def __init__(self, mu, sigma):
        
        n = 0
        for cycle in mu:
            n += len(cycle)
        
        self.n = n
        self.mu = Permutation(mu)
        self.sigma = Permutation(sigma)
        self.phi = (self.mu**(-1)) * self.sigma
        
        self.gem = "not computed"
        self.genus = "not computed"
        self.num_symmetries = "not computed"
        self.weight = "not computed"
        self.isomorphism_signature = "not computed"
        
        
    def connected_graph(self):
        """
        Determines whether the GEM is connected by checking the transitivity of the subgroup generated by (mu, sigma).
        """
        
        sub_group = PermutationGroup([self.mu, self.sigma])
        return sub_group.is_transitive()
    
    
    def compute_genus(self):
        """
        Computes the genus of the surface represented by the triangulation.
        Result is stored as an attribute.
        """
    
        v = self.mu.cycles + self.sigma.cycles + self.phi.cycles
        chi = v - self.n
        g = (2 - chi) / 2

        self.genus = int(g)
    
    
    def compute_gem(self):
        """
        Computes the GEM as a dictionary of lists.
        E.g. {"red": [2,3,0,1]} means there are red arcs between 0 and 2 (i.e. 0 and 0'), and 1 and 3 (i.e. 1 and 1').
        Result is stored as an attribute.
        """

        red = [None] * (2*self.n)
        green = [None] * (2*self.n)
        blue = [None] * (2*self.n)

        for i in range(self.n):    
            red[i] = i + self.n
            red[i + self.n] = i

            green[i] = self.mu(i) + self.n
            green[self.mu(i) + self.n] = i

            blue[i] = self.sigma(i) + self.n
            blue[self.sigma(i) + self.n] = i

        gem = {"red": red,
               "green": green,
               "blue": blue}

        self.gem = gem
    
    
    def symmetry(self, new_node, swap):
        """
        Given a colour swap and a new node to relocate 0 to, checks whether this is a symmetry.
        Returns either "symmetry" or "not a symmetry".
        """        
        
        if self.gem == "not computed":
            raise Exception("GEM has not been computed for this Triangulation.")
            
        swap_dict = {"red": swap[0],
                     "green": swap[1],
                     "blue": swap[2]}
        
        mapping = {0: new_node}
        stack = [(0, new_node)]

        while stack != []:
            current = stack.pop()

            for colour in ["red", "green", "blue"]:
                
                old = self.gem[colour][current[0]]
                new = self.gem[swap_dict[colour]][current[1]]

                if old not in mapping:
                    mapping[old] = new
                    stack.append((old, new))

                elif mapping[old] != new:
                    return "not a symmetry"

        if len(mapping.values()) == len(set(mapping.values())):
            return "symmetry"
        else:
            return "not a symmetry"
    
    
    def compute_num_symmetries(self):
        """
        Computes the number of symmetries in each of the 6 colour swaps by iterating over all 2n node relocations.
        Result is stored as an attribute.
        """

        num_symmetries = []
        
        for swap in self.all_swaps:
            num_symmetries.append(0)

            for i in range(2*self.n):
                if self.symmetry(i, swap) == "symmetry":
                    num_symmetries[-1] += 1

        self.num_symmetries = num_symmetries
    
    
    def tau(self):
        """
        Based on the number of colour swap symmetries, computes which bi-coloured permutations need to be considered in compute_weight().
        """
        
        if self.num_symmetries == "not computed":
            raise Exception("Number of symmetries has not been computed for this Triangulation.")
            
        non_zero = 0
        for num in self.num_symmetries:
            if num != 0:
                non_zero += 1

        if non_zero == 1:
            return [0,1,2,3,4,5]

        elif non_zero == 2:
            return [0,2,5]

        elif non_zero == 3:
            return [0,1]

        elif non_zero == 6:
            return [0]

        else:
            raise Exception("Number of colour swap symmetries is not 1, 2, 3 or 6!")

            
    def compute_weight(self):
        """
        Computes the 1/w(mu, sigma) number given by the equation at the end of Section 3.3 in the AMSI VRS report.
        Result is stored as an attribute.
        """
        
        col_to_perm = {"red": Permutation(self.n - 1),
                       "green": self.mu,
                       "blue": self.sigma}

        cent_card_sum = 0
        for swap in [self.all_swaps[i] for i in self.tau()]:

            bi_colour = (col_to_perm[swap[0]]**(-1)) * col_to_perm[swap[1]]
            a = bi_colour.cycle_structure

            cent_card = 1
            for j in a:
                cent_card *= (j**a[j]) * math.factorial(a[j])

            cent_card_sum += cent_card
            
        self.weight = (2/self.num_symmetries[0]) * cent_card_sum
        
        
    def isomorphism_signature_candidate(self, start_node, swap):
        """
        Isomorphism signature candidates are strings of 3n numbers.
        There are 12n possible signature candidates depending on the starting node and colour swap.
        This function calculates one signature candidate and returns it.
        """
        
        if self.gem == "not computed":
            raise Exception("GEM has not been computed for this Triangulation.")

        gem_copy = copy.deepcopy(self.gem)
        symbols = {start_node: "0"}
        queue = [start_node]
        signature_candidate = ""
        counter = 1
        
        while queue != []:
            current = queue.pop(0)
            
            for colour in swap:
                
                adjacent = self.gem[colour][current]     
                if gem_copy[colour][min(current, adjacent)] != "used":

                    if adjacent not in symbols:
                        symbols[adjacent] = str(counter)
                        counter += 1
                        
                    signature_candidate += symbols[adjacent]
                    queue.append(adjacent)
                    gem_copy[colour][min(current, adjacent)] = "used"

        return signature_candidate
    
        
    def compute_isomorphism_signature(self):
        """
        Computes all 12n isomorphism signature candidates.
        Looks for the lexicographically smallest signature candidate.
        This is the isomorphism signature.        
        Result is stored as an attribute.
        """
        
        current_best = "z"
        for swap in self.all_swaps:
            for i in range(2*self.n):
                candidate = self.isomorphism_signature_candidate(i, swap)
                if candidate < current_best:
                    current_best = candidate
                
        self.isomorphism_signature = current_best
        
        
    def __repr__(self):
        
        return "mu = {}\nsigma = {}".format(str(self.mu.full_cyclic_form), str(self.sigma.full_cyclic_form))